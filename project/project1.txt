module firfilter(
input clk,
input rst,
input [7:0] x,
input [7:0] h0, h1, h2, h3, h4, h5, h6, h7,
h8, h9, h10, h11, h12, h13, h14, h15,
h16, h17, h18, h19, h20, h21, h22, h23,
h24, h25, h26, h27, h28, h29, h30, h31,
output [8:0] y);   // Shift registers (D Flip-Flops)
wire [7:0] x1, x2, x3, x4, x5, x6, x7,
x8, x9, x10, x11, x12, x13, x14, x15,
x16, x17, x18, x19, x20, x21, x22, x23,
x24, x25, x26, x27, x28, x29, x30, x31;
// Product outputs from multipliers
wire [15:0] y0, y1, y2, y3, y4, y5, y6, y7,
y8, y9, y10, y11, y12, y13, y14, y15,
y16, y17, y18, y19, y20, y21, y22, y23,
y24, y25, y26, y27, y28, y29, y30, y31;
// Intermediate sums and carries (8-bit adders used iteratively)
wire [7:0] s1, s2, s3, s4, s5, s6, s7, s8;
wire [7:0] s9, s10, s11, s12, s13, s14, s15, s16;
wire [7:0] s17, s18, s19, s20, s21, s22, s23, s24;
wire [7:0] s25, s26, s27, s28, s29, s30, s31;
wire c1, c2, c3, c4, c5, c6, c7, c8;
wire c9, c10, c11, c12, c13, c14, c15, c16;
wire c17, c18, c19, c20, c21, c22, c23, c24;
wire c25, c26, c27, c28, c29, c30, c31;
// Input buffering
//assign x0 = x;
// Instantiate D flip-flops (Shift Register Chain)
FF d1(clk, rst, x, x1);
FF d2(clk, rst, x1, x2);
FF d3(clk, rst, x2, x3);
FF d4(clk, rst, x3, x4);
FF d5(clk, rst, x4, x5);
FF d6(clk, rst, x5, x6);
FF d7(clk, rst, x6, x7);
46
FF d8(clk, rst, x7, x8);
FF d9(clk, rst, x8, x9);
FF d10(clk, rst, x9, x10);
FF d11(clk, rst, x10, x11);
FF d12(clk, rst, x11, x12);
FF d13(clk, rst, x12, x13);
FF d14(clk, rst, x13, x14);
FF d15(clk, rst, x14, x15);
FF d16(clk, rst, x15, x16);
FF d17(clk, rst, x16, x17);
FF d18(clk, rst, x17, x18);
FF d19(clk, rst, x18, x19);
FF d20(clk, rst, x19, x20);
FF d21(clk, rst, x20, x21);
FF d22(clk, rst, x21, x22);
FF d23(clk, rst, x22, x23);
FF d24(clk, rst, x23, x24);
FF d25(clk, rst, x24, x25);
FF d26(clk, rst, x25, x26);
FF d27(clk, rst, x26, x27);
FF d28(clk, rst, x27, x28);
FF d29(clk, rst, x28, x29);
FF d30(clk, rst, x29, x30);
FF d31(clk, rst, x30, x31);
// Instantiate multipliers
vedic8 vm0(y0, x, h0);
vedic8 vm1(y1, x1, h1);
vedic8 vm2(y2, x2, h2);
vedic8 vm3(y3, x3, h3);
vedic8 vm4(y4, x4, h4);
vedic8 vm5(y5, x5, h5);
vedic8 vm6(y6, x6, h6);
vedic8 vm7(y7, x7, h7);
vedic8 vm8(y8, x8, h8);
47
vedic8 vm9(y9, x9, h9);
vedic8 vm10(y10, x10, h10);
vedic8 vm11(y11, x11, h11);
vedic8 vm12(y12, x12, h12);
vedic8 vm13(y13, x13, h13);
vedic8 vm14(y14, x14, h14);
vedic8 vm15(y15, x15, h15);
vedic8 vm16(y16, x16, h16);
vedic8 vm17(y17, x17, h17);
vedic8 vm18(y18, x18, h18);
vedic8 vm19(y19, x19, h19);
vedic8 vm20(y20, x20, h20);
vedic8 vm21(y21, x21, h21);
vedic8 vm22(y22, x22, h22);
vedic8 vm23(y23, x23, h23);
vedic8 vm24(y24, x24, h24);
vedic8 vm25(y25, x25, h25);
vedic8 vm26(y26, x26, h26);
vedic8 vm27(y27, x27, h27);
vedic8 vm28(y28, x28, h28);
vedic8 vm29(y29, x29, h29);
vedic8 vm30(y30, x30, h30);
vedic8 vm31(y31, x31, h31);
// Adder chain â€” each adder adds next product to accumulated sum
adder16 a1(s1, c1, y0,y1, 1'b0);
adder16 a2(s2, c2, s1, y2, c1);
adder16 a3(s3, c3, s2, y3, c2);
adder16 a4(s4, c4, s3, y4, c3);
adder16 a5(s5, c5, s4, y5, c4);
adder16 a6(s6, c6, s5, y6, c5);
adder16 a7(s7, c7, s6, y7, c6);
adder16 a8(s8, c8, s7, y8, c7);
adder16 a9(s9, c9, s8, y9, c8);
adder16 a10(s10, c10, s9, y10,c9);
48
adder16 a11(s11, c11, s10, y11,c10);
adder16 a12(s12, c12, s11, y12,c11);
adder16 a13(s13, c13, s12, y13,c12);
adder16 a14(s14, c14, s13, y14,c13);
adder16 a15(s15, c15, s14, y15,c14);
adder16 a16(s16, c16, s15, y16,c15);
adder16 a17(s17, c17, s16, y17,c16);
adder16 a18(s18, c18, s17, y18,c17);
adder16 a19(s19, c19, s18, y19,c18);
adder16 a20(s20, c20, s19, y20,c19);
adder16 a21(s21, c21, s20, y21,c20);
adder16 a22(s22, c22, s21, y22,c21);
adder16 a23(s23, c23, s22, y23,c22);
adder16 a24(s24, c24, s23, y24,c23);
adder16 a25(s25, c25, s24, y25,c24);
adder16 a26(s26, c26, s25, y26,c25);
adder16 a27(s27, c27, s26, y27,c26);
adder16 a28(s28, c28, s27, y28,c27);
adder16 a29(s29, c29, s28, y29,c28);
adder16 a30(s30, c30, s29, y30,c29);
adder16 a31(s31, c31, s30, y31,c30);
// Final output
assign y = {c31,s31};
endmodule
// 16-bit Ripple carry adder
module adder16(s, carry, a, b, cin);
input [15:0] a, b;
input cin;
output [15:0] s;
output carry;
wire c0, c1, c2, c3, c4, c5, c6, c7;
49
wire c8, c9, c10, c11, c12, c13, c14;
fulladder fa0(s[0], c0, a[0], b[0], cin);
fulladder fa1(s[1], c1, a[1], b[1], c0);
fulladder fa2(s[2], c2, a[2], b[2], c1);
fulladder fa3(s[3], c3, a[3], b[3], c2);
fulladder fa4(s[4], c4, a[4], b[4], c3);
fulladder fa5(s[5], c5, a[5], b[5], c4);
fulladder fa6(s[6], c6, a[6], b[6], c5);
fulladder fa7(s[7], c7, a[7], b[7], c6);
fulladder fa8(s[8], c8, a[8], b[8], c7);
fulladder fa9(s[9], c9, a[9], b[9], c8);
fulladder fa10(s[10], c10, a[10], b[10], c9);
fulladder fa11(s[11], c11, a[11], b[11], c10);
fulladder fa12(s[12], c12, a[12], b[12], c11);
fulladder fa13(s[13], c13, a[13], b[13], c12);
fulladder fa14(s[14], c14, a[14], b[14], c13);
fulladder fa15(s[15], carry, a[15], b[15], c14);
endmodule
// D Flip Flop
module FF (
input clk,
input rst,
input [7:0] d,
output reg [7:0] q
);
always @ (posedge clk or posedge rst)
begin
if (rst)
q <= 8'd0;
else
q <= d;
end
endmodule
50
// 8x8 Vedic multiplier
module vedic8(s,a,b);
input [7:0]a,b;
output [15:0]s;
wire c1,c2,c3;
wire [7:0]w,x,y,z;
wire [7:0]sum2,p1,sum1,sum3,p2;
wire [15:0]final;
wire [7:0]s_high;
vedic4 vm1(w,a[3:0],b[3:0]);
vedic4 vm2(x,a[3:0],b[7:4]);
vedic4 vm3(y,a[7:4],b[3:0]);
vedic4 vm4(z,a[7:4],b[7:4]);
adder8 add1(sum1,c1,x,y,1'b0);
assign p1={4'b0000,w[7:4]};
adder8 add2(sum2,c2,p1,sum1[7:0],1'b0);
assign p2={c1,3'b000,sum2[7:4]};
adder8 add3(s_high,c3,z[7:0],p2,1'b0);
assign final[15:8]=s_high;
assign final[7:4]=sum2[3:0];
assign final[3:0]=w[3:0];
assign s=final;
endmodule
//4x4 Vedic multiplier
module vedic4(s, a, b);
input [3:0] a, b;
output [8:0] s;
wire [3:0] q0, q1, q2, q3;
wire [3:0] sum1, x1;
wire [4:0] p1, p3;
wire c1, c2, c_or, s8;
wire [8:0] final;
51
vedic2 vm1(q0, a[1:0], b[1:0]);
vedic2 vm2(q1, a[3:2], b[1:0]);
vedic2 vm3(q2, a[1:0], b[3:2]);
vedic2 vm4(q3, a[3:2], b[3:2]);
adder4 add1(sum1, c1, q1, q2, 1'b0);
assign p1 = {1'b0, 1'b0, q0[3:2]};
adder4 add2(x1, c2, sum1, p1[3:0], 1'b0);
or(c_or, c1, c2);
assign p3 = {1'b0, c_or, x1[3:2]};
wire [3:0] s_high;
adder4 add3(s_high, s8, q3, p3[3:0], 1'b0);
assign final[8] = s8;
assign final[7:4] = s_high;
assign final[3:2] = x1[1:0];
assign final[1:0] = q0[1:0];
assign s = final;
endmodule
// 2x2 Vedic Multiplier
module vedic2(s, a, b);
input [1:0] a, b;
output [3:0] s;
wire c, d, e, f;
and(s[0], a[0], b[0]);
and(c, a[1], b[0]);
and(d, a[0], b[1]);
and(e, a[1], b[1]);
halfadder h1(s[1], f, c, d);
halfadder h2(s[2], s[3], e, f);
endmodule
// Half Adder
52
module halfadder(s, c, a, b);
input a, b;
output s, c;
assign s = a ^ b;
assign c = a & b;
endmodule
// 4-bit Ripple Carry Adder
module adder4(s, cout, a, b, cin);
input [3:0] a, b;
input cin;
output [3:0] s;
output cout;
wire c1, c2, c3;
fulladder fa1(s[0], c1, a[0], b[0], cin);
fulladder fa2(s[1], c2, a[1], b[1], c1);
fulladder fa3(s[2], c3, a[2], b[2], c2);
fulladder fa4(s[3], cout, a[3], b[3], c3);
endmodule
//8 bit ripple carry adder
module adder8(s,carry,a,b,cin);
input [7:0]a,b;
input cin;
output carry;
output [7:0]s;
wire c0,c1,c2,c3,c4,c5,c6;
fulladder fa1(s[0],c0,a[0],b[0],cin);
fulladder fa2(s[1],c1,a[1],b[1],c0);
fulladder fa3(s[2],c2,a[2],b[2],c1);
fulladder fa4(s[3],c3,a[3],b[3],c2);
fulladder fa5(s[4],c4,a[4],b[4],c3);
fulladder fa6(s[5],c5,a[5],b[5],c4);
53
fulladder fa7(s[6],c6,a[6],b[6],c5);
fulladder fa8(s[7],carry,a[7],b[7],c6);
endmodule
// Full Adder
module fulladder(sum, carry, a, b, c);
input a, b, c;
output sum, carry;
wire w1, w2, w3;
xor(w1, a, b);
xor(sum, w1, c);
and(w2, w1, c);
and(w3, a, b);
or(carry, w2, w3);
endmodule